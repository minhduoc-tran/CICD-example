import { test, expect } from "@playwright/test";
import { HomePage } from "./pages/home-page";
import { TestHelpers } from "./utils/test-helpers";
import { VisualRegression } from "./utils/visual-regression";
import { TEST_DATA } from "./fixtures/test-data";

test.describe("Home Page - Critical User Flows", () => {
  let homePage: HomePage;

  test.beforeEach(async ({ page }) => {
    homePage = new HomePage(page);
  });

  test.describe("Homepage Loading and Rendering", () => {
    test("should load homepage successfully with all elements", async ({
      page,
    }) => {
      // Track console errors during page load
      const consoleErrors: string[] = [];
      page.on("console", (msg) => {
        if (msg.type() === "error") {
          consoleErrors.push(msg.text());
        }
      });

      // Navigate to homepage
      await homePage.goto();

      // Verify page loads without errors
      expect(consoleErrors).toHaveLength(0);

      // Verify all critical elements are present and visible
      await homePage.verifyPageElements();

      // Verify content matches expected values
      const headingText = await homePage.getHeadingText();
      const descriptionText = await homePage.getDescriptionText();

      expect(headingText).toBe(TEST_DATA.homePage.heading);
      expect(descriptionText).toBe(TEST_DATA.homePage.description);
    });

    test("should have correct page metadata", async ({ page }) => {
      await homePage.goto();

      // Verify page title
      await expect(page).toHaveTitle(TEST_DATA.homePage.title);

      // Verify meta description
      const metaDescription = page.locator('meta[name="description"]');
      await expect(metaDescription).toHaveAttribute(
        "content",
        "Generated by create next app"
      );

      // Verify language attribute
      const htmlElement = page.locator("html");
      await expect(htmlElement).toHaveAttribute("lang", "en");
    });

    test("should load fonts and styles correctly", async ({ page }) => {
      await homePage.goto();

      // Wait for fonts to load
      await TestHelpers.waitForFonts(page);

      // Verify font variables are applied (check for actual class names)
      const bodyElement = page.locator("body");
      await expect(bodyElement).toHaveClass(/variable/); // Font variables contain "variable"
      await expect(bodyElement).toHaveClass(/antialiased/);

      // Verify fonts are actually loaded
      const fontFamilies = await page.evaluate(() => {
        const computedStyle = window.getComputedStyle(document.body);
        return computedStyle.fontFamily;
      });

      // Should contain font family information
      expect(fontFamilies).toBeTruthy();
    });

    test("should handle slow network conditions gracefully", async ({
      page,
    }) => {
      // Simulate slow network
      await TestHelpers.simulateSlowNetwork(page);

      // Navigate and verify page still loads
      await homePage.goto();
      await homePage.verifyPageElements();
    });
  });

  test.describe("Responsive Design Testing", () => {
    test("should display correctly on mobile devices", async ({ page }) => {
      await TestHelpers.setBreakpoint(page, "mobile");
      await homePage.goto();

      // Verify elements are visible and properly positioned
      await homePage.verifyPageElements();
      await homePage.verifyResponsiveLayout();

      // Check that text is readable on mobile
      const heading = homePage.heading;
      const headingBox = await heading.boundingBox();
      expect(headingBox?.width).toBeLessThan(350); // Should fit in mobile viewport
    });

    test("should display correctly on tablet devices", async ({ page }) => {
      await TestHelpers.setBreakpoint(page, "tablet");
      await homePage.goto();

      await homePage.verifyPageElements();
      await homePage.verifyResponsiveLayout();
    });

    test("should display correctly on desktop", async ({ page }) => {
      await TestHelpers.setBreakpoint(page, "desktop");
      await homePage.goto();

      await homePage.verifyPageElements();
      await homePage.verifyResponsiveLayout();
    });

    test("should display correctly on large desktop", async ({ page }) => {
      await TestHelpers.setBreakpoint(page, "largeDesktop");
      await homePage.goto();

      await homePage.verifyPageElements();
      await homePage.verifyResponsiveLayout();
    });

    test("should maintain layout integrity across all breakpoints", async ({
      page,
    }) => {
      await homePage.goto();

      for (const [breakpointName] of Object.entries(TestHelpers.BREAKPOINTS)) {
        await TestHelpers.setBreakpoint(
          page,
          breakpointName as keyof typeof TestHelpers.BREAKPOINTS
        );

        // Wait for layout to adjust
        await page.waitForTimeout(300);

        // Verify elements are still visible and properly positioned
        await homePage.verifyPageElements();

        // Verify flexbox layout is maintained
        const container = page.locator(TEST_DATA.selectors.mainContainer);
        await expect(container).toHaveClass(/flex/);
        await expect(container).toHaveClass(/items-center/);
        await expect(container).toHaveClass(/justify-center/);
      }
    });

    test("should support dark mode across all devices", async ({ page }) => {
      // Test dark mode on different breakpoints
      for (const [breakpointName] of Object.entries(TestHelpers.BREAKPOINTS)) {
        await TestHelpers.setBreakpoint(
          page,
          breakpointName as keyof typeof TestHelpers.BREAKPOINTS
        );

        await homePage.goto();

        // Enable dark mode
        await page.evaluate(() => {
          document.documentElement.classList.add("dark");
        });

        await page.waitForTimeout(300);

        // Verify dark mode classes are applied
        await homePage.verifyDarkModeSupport();

        // Verify elements are still visible in dark mode
        await homePage.verifyPageElements();

        // Clean up
        await page.evaluate(() => {
          document.documentElement.classList.remove("dark");
        });
      }
    });
  });

  test.describe("Accessibility and Performance", () => {
    test("should meet basic accessibility requirements", async ({ page }) => {
      await homePage.goto();

      const accessibility = await TestHelpers.checkBasicAccessibility(page);
      expect(accessibility.hasMainHeading).toBe(true);
      expect(accessibility.hasLangAttribute).toBe(true);

      // Verify heading hierarchy
      const h1Count = await page.locator("h1").count();
      expect(h1Count).toBe(1);

      // Verify color contrast (basic check)
      const heading = homePage.heading;
      const headingStyles = await heading.evaluate((el) => {
        const styles = window.getComputedStyle(el);
        return {
          color: styles.color,
          backgroundColor: styles.backgroundColor,
        };
      });

      // Ensure text color is not transparent
      expect(headingStyles.color).not.toBe("rgba(0, 0, 0, 0)");
    });

    test("should load within performance budget", async ({ page }) => {
      const startTime = Date.now();

      await homePage.goto();
      await TestHelpers.waitForNetworkIdle(page);

      const loadTime = Date.now() - startTime;

      // Should load within 3 seconds
      expect(loadTime).toBeLessThan(3000);
    });
  });
});

test.describe("Visual Regression Tests", () => {
  let homePage: HomePage;

  test.beforeEach(async ({ page }) => {
    homePage = new HomePage(page);
  });

  test("should match homepage baseline screenshot", async ({ page }) => {
    await homePage.goto();
    await TestHelpers.waitForFonts(page);

    await VisualRegression.comparePageScreenshot(page, "homepage-baseline");
  });

  test("should match responsive design screenshots", async ({ page }) => {
    await homePage.goto();

    const breakpoints = Object.entries(TEST_DATA.viewports).map(
      ([name, size]) => ({
        name,
        ...size,
      })
    );

    await VisualRegression.testResponsiveScreenshots(
      page,
      "homepage-responsive",
      breakpoints
    );
  });

  test("should match dark mode visual regression", async ({ page }) => {
    await homePage.goto();

    await VisualRegression.testDarkModeScreenshot(page, "homepage-dark");
  });

  test("should match component-level screenshots", async ({ page }) => {
    await homePage.goto();
    await TestHelpers.waitForFonts(page);

    // Test individual components
    await VisualRegression.compareElementScreenshot(
      page,
      "h1",
      "homepage-heading"
    );

    await VisualRegression.compareElementScreenshot(
      page,
      "p",
      "homepage-description"
    );
  });

  test("should detect visual changes in layout", async ({ page }) => {
    await homePage.goto();

    // Test with different viewport sizes to catch layout issues
    const criticalBreakpoints = [
      { name: "mobile", width: 375, height: 667 },
      { name: "tablet", width: 768, height: 1024 },
      { name: "desktop", width: 1280, height: 720 },
    ];

    for (const breakpoint of criticalBreakpoints) {
      await page.setViewportSize({
        width: breakpoint.width,
        height: breakpoint.height,
      });

      await page.waitForTimeout(300);
      await TestHelpers.waitForFonts(page);

      await VisualRegression.comparePageScreenshot(
        page,
        `homepage-layout-${breakpoint.name}`,
        { fullPage: true }
      );
    }
  });
});
